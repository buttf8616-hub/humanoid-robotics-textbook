---
title: "Chapter 1: ROS 2 Architecture and Fundamentals"
description: "Understanding the architecture and core concepts of ROS 2 for humanoid robotics"
hide_table_of_contents: false
keywords: ["ROS 2", "Robot Operating System", "Nodes", "Topics", "Services", "Actions", "Middleware"]
sidebar_position: 1
---

# Chapter 1: ROS 2 Architecture and Fundamentals

## Learning Objectives
- Understand the ROS 2 architecture and its components
- Implement nodes, topics, services, and actions
- Design communication patterns for humanoid robot control
- Apply ROS 2 concepts to robotics applications
- Utilize ROS 2 tools for debugging and monitoring

## Introduction to ROS 2

The Robot Operating System 2 (ROS 2) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms and environments. Unlike traditional operating systems, ROS 2 is middleware that provides hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more.

### Evolution from ROS 1 to ROS 2

ROS 2 was developed to address the limitations of the original ROS, including:
- Improved security for production environments
- Better real-time support
- Enhanced scalability and reliability
- Platform independence
- Quality of service (QoS) policies
- Official support for Windows and macOS

### Core Design Philosophy

ROS 2 follows a distributed computing model where:
- Multiple processes (nodes) can run on different machines
- Communication occurs through a publish-subscribe pattern
- Data types are standardized through messages
- System composition is flexible and dynamic
- Tools exist for introspection and debugging

## ROS 2 Architecture

### DDS (Data Distribution Service) Layer

ROS 2 uses DDS as its underlying communication layer, providing:
- Publish-subscribe communication
- Service-request patterns
- Discovery mechanisms
- Quality of service configurations
- Security features
- Platform independence

### Core Components

#### Nodes
Nodes are processes that perform computation. Nodes are organized into packages to create, build, and share code. A running ROS 2 system consists of multiple nodes that communicate with each other.

```python
import rclpy
from rclpy.node import Node

class HumanoidController(Node):
    def __init__(self):
        super().__init__('humanoid_controller')
        self.get_logger().info('Humanoid Controller node initialized')

def main(args=None):
    rclpy.init(args=args)
    controller = HumanoidController()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Topics and Messages
Topics enable asynchronous message passing between nodes. Messages are the data packets sent over topics. Each topic has a specific message type that defines its structure.

```python
# Publisher example
from std_msgs.msg import String
import rclpy
from rclpy.node import Node

class JointStatePublisher(Node):
    def __init__(self):
        super().__init__('joint_state_publisher')
        self.publisher = self.create_publisher(String, 'joint_commands', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

    def timer_callback(self):
        msg = String()
        msg.data = 'Joint position update'
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: {msg.data}')
```

#### Services
Services provide synchronous request/response communication. A service client sends a request and waits for a response from the service server.

```python
# Service server example
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class AddService(Node):
    def __init__(self):
        super().__init__('add_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_callback)

    def add_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Returning {response.sum}')
        return response
```

#### Actions
Actions are used for long-running tasks that provide feedback and can be canceled. They're ideal for humanoid robot behaviors that take time to complete.

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from control_msgs.action import FollowJointTrajectory

class TrajectoryActionClient(Node):
    def __init__(self):
        super().__init__('trajectory_action_client')
        self._action_client = ActionClient(
            self,
            FollowJointTrajectory,
            'follow_joint_trajectory'
        )
```

## Quality of Service (QoS) Profiles

QoS profiles allow fine-tuning of communication characteristics:

```python
from rclpy.qos import QoSProfile, QoSDurabilityPolicy, QoSHistoryPolicy, QoSReliabilityPolicy

# Custom QoS profile for real-time control
custom_qos_profile = QoSProfile(
    reliability=QoSReliabilityPolicy.RELIABLE,
    durability=QoSDurabilityPolicy.VOLATILE,
    history=QoSHistoryPolicy.KEEP_LAST,
    depth=10
)

publisher = self.create_publisher(String, 'critical_topic', custom_qos_profile)
```

### Common QoS Settings:
- **Reliability**: RELIABLE vs BEST_EFFORT
- **Durability**: VOLATILE vs TRANSIENT_LOCAL
- **History**: KEEP_ALL vs KEEP_LAST
- **Depth**: Size of message queue

## Creating ROS 2 Packages

ROS 2 packages are the fundamental building blocks of ROS programs.

### Package Structure
```
humanoid_robot_controller/
├── CMakeLists.txt          # Build configuration for C++
├── package.xml             # Package metadata
├── setup.py               # Build configuration for Python
├── setup.cfg              # Installation configuration
├── resource/              # Package resources
│   └── humanoid_robot_controller
├── test/                  # Unit tests
│   ├── test_copyright.py
│   ├── test_flake8.py
│   └── test_pep257.py
└── humanoid_robot_controller/  # Source code
    ├── __init__.py
    └── controller.py
```

### Creating a Package
```bash
# Create a new package
ros2 pkg create --build-type ament_python humanoid_robot_controller

# Or for C++
ros2 pkg create --build-type ament_cmake humanoid_robot_controller_cpp
```

## Working with Workspaces

ROS 2 workspaces are directories where you modify, build, and install ROS 2 packages.

### Workspace Structure
```
~/humanoid_ws/
├── src/          # Source code
│   └── humanoid_robot_controller/
├── build/        # Build artifacts
├── install/      # Installed packages
└── log/          # Build logs
```

### Building and Sourcing
```bash
# Create workspace
mkdir -p ~/humanoid_ws/src
cd ~/humanoid_ws

# Build workspace
colcon build --packages-select humanoid_robot_controller

# Source the workspace
source install/setup.bash
```

## Communication Patterns for Humanoid Robots

### Publisher-Subscriber Pattern for Sensor Data

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from builtin_interfaces.msg import Time

class SensorFusionNode(Node):
    def __init__(self):
        super().__init__('sensor_fusion_node')
        self.subscription = self.create_subscription(
            JointState,
            'joint_states',
            self.listener_callback,
            10)
        self.publisher = self.create_publisher(JointState, 'processed_joint_states', 10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        # Process sensor data
        processed_msg = JointState()
        processed_msg.name = msg.name
        processed_msg.position = [pos * 0.99 for pos in msg.position]  # Example processing
        processed_msg.header.stamp = self.get_clock().now().to_msg()

        self.publisher.publish(processed_msg)
```

### Service Pattern for Robot Control Commands

```python
from example_interfaces.srv import Trigger
import rclpy
from rclpy.node import Node

class RobotCommandServer(Node):
    def __init__(self):
        super().__init__('robot_command_server')
        self.srv = self.create_service(
            Trigger,
            'execute_robot_behavior',
            self.execute_behavior_callback
        )

    def execute_behavior_callback(self, request, response):
        # Execute robot behavior
        self.get_logger().info('Executing robot behavior...')
        # Perform behavior execution logic here
        response.success = True
        response.message = 'Behavior executed successfully'
        return response
```

### Action Pattern for Complex Behaviors

```python
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from control_msgs.action import FollowJointTrajectory
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup

class JointTrajectoryServer(Node):
    def __init__(self):
        super().__init__('joint_trajectory_server')
        self._action_server = ActionServer(
            self,
            FollowJointTrajectory,
            'follow_joint_trajectory',
            self.execute_trajectory_callback
        )

    def execute_trajectory_callback(self, goal_handle):
        self.get_logger().info('Executing trajectory...')

        # Execute the trajectory here
        feedback = FollowJointTrajectory.Feedback()
        result = FollowJointTrajectory.Result()

        # Send feedback periodically
        for i in range(100):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result.error_code = -1
                return result

            # Update feedback
            feedback.actual.positions = [0.0] * len(feedback.actual.positions)
            goal_handle.publish_feedback(feedback)

            # Sleep briefly
            self.get_clock().sleep_for(Duration(seconds=0.1))

        goal_handle.succeed()
        result.error_code = 0
        return result
```

## Python Agents with rclpy

rclpy is the Python client library for ROS 2. It provides the functionality to create ROS 2 nodes, publish and subscribe to topics, make service calls, and provide services.

### Creating a Simple Robot Controller

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Bool

class RobotController(Node):
    def __init__(self):
        super().__init__('robot_controller')

        # Publisher for velocity commands
        self.cmd_vel_publisher = self.create_publisher(Twist, 'cmd_vel', 10)

        # Subscriber for laser scan data
        self.scan_subscriber = self.create_subscription(
            LaserScan,
            'scan',
            self.scan_callback,
            10
        )

        # Publisher for collision alerts
        self.collision_publisher = self.create_publisher(Bool, 'collision_alert', 10)

        # Timer for control loop
        self.timer = self.create_timer(0.1, self.control_loop)

        self.front_distance = float('inf')
        self.get_logger().info('Robot controller initialized')

    def scan_callback(self, msg):
        # Process laser scan data
        if len(msg.ranges) > 0:
            self.front_distance = min(msg.ranges[0:10] + msg.ranges[-10:])

    def control_loop(self):
        cmd_vel = Twist()

        # Simple obstacle avoidance
        collision_alert = Bool()
        if self.front_distance < 0.5:
            collision_alert.data = True
            cmd_vel.linear.x = 0.0  # Stop
            cmd_vel.angular.z = 1.0  # Turn to avoid obstacle
        elif self.front_distance < 1.0:
            cmd_vel.linear.x = 0.2  # Slow down
            cmd_vel.angular.z = 0.0
        else:
            cmd_vel.linear.x = 0.5  # Move forward
            cmd_vel.angular.z = 0.0

        self.cmd_vel_publisher.publish(cmd_vel)
        self.collision_publisher.publish(collision_alert)

def main(args=None):
    rclpy.init(args=args)
    robot_controller = RobotController()

    try:
        rclpy.spin(robot_controller)
    except KeyboardInterrupt:
        pass
    finally:
        robot_controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Launch Files for Complex Systems

Launch files allow you to start multiple nodes with a single command:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='humanoid_robot_controller',
            executable='controller_node',
            name='humanoid_controller',
            output='screen',
            parameters=[
                {'param_name': 'param_value'},
            ]
        ),
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz',
            arguments=['-d', os.path.join(get_package_share_directory('humanoid_robot_controller'), 'config', 'config.rviz')]
        ),
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher'
        )
    ])
```

## Best Practices for ROS 2 Development

1. **Use meaningful node and topic names**: Choose names that clearly indicate the purpose of the node or topic.

2. **Implement proper error handling**: Always handle potential exceptions in your ROS 2 nodes.

3. **Use parameter servers**: Store configuration values in parameters rather than hardcoding them.

4. **Follow naming conventions**: Use snake_case for node names, topics, and services.

5. **Implement lifecycle nodes**: For complex systems that need proper initialization and cleanup.

6. **Apply Quality of Service (QoS)**: Use appropriate QoS settings for different types of communication.

7. **Use composition**: Consider node composition for better performance and reduced communication overhead.

8. **Log appropriately**: Use different log levels appropriately (debug, info, warn, error).

## Tools for Development and Debugging

### Command Line Tools
```bash
# List all topics
ros2 topic list

# Echo a topic
ros2 topic echo /joint_states sensor_msgs/msg/JointState

# Call a service
ros2 service call /trigger_behavior example_interfaces/srv/Trigger

# List all nodes
ros2 node list

# Get information about a node
ros2 node info /humanoid_controller
```

### Visualization Tools
- **RViz2**: 3D visualization of robot state and sensor data
- **rqt**: GUI-based tools for monitoring and controlling
- **PlotJuggler**: Real-time plotting of ROS topics

## Security Considerations

ROS 2 includes security features:
- Authentication and encryption
- Secure discovery and communication
- Access control mechanisms
- Secure node-to-node communication

## Summary

ROS 2 provides the essential middleware infrastructure for developing complex robotic systems, particularly humanoid robots that require coordination between multiple subsystems. The architecture of nodes, topics, services, and actions enables flexible communication patterns that can handle the complexity of humanoid robot control. Understanding these fundamentals is crucial for implementing advanced humanoid robotics applications.

## Exercises

1. Create a simple ROS 2 publisher that publishes joint position commands for a humanoid robot's arm.
2. Implement a ROS 2 service that receives a target position and returns whether the humanoid robot can reach it.
3. Design a launch file that starts multiple nodes for a humanoid robot's walking controller.