---
title: "Chapter 1: Gazebo Simulation Environments"
description: "Comprehensive guide to Gazebo physics simulation for humanoid robotics"
hide_table_of_contents: false
keywords: ["Gazebo", "Physics Simulation", "Robotics Simulation", "Humanoid Robotics", "3D Simulation"]
sidebar_position: 1
---

# Chapter 1: Gazebo Simulation Environments

## Learning Objectives
- Understand the fundamentals of Gazebo physics simulation
- Configure Gazebo environments for humanoid robot testing
- Implement sensor modeling and environment creation
- Master physics parameters for realistic simulation
- Validate robot behaviors in simulated environments

## Introduction to Gazebo Simulation

Gazebo is a powerful open-source physics simulator that provides realistic simulation environments for robotics development. For humanoid robotics, Gazebo offers sophisticated physics engines, sensor simulation, and visualization capabilities that enable comprehensive testing of control algorithms before real-world deployment.

### Key Features of Gazebo

Gazebo provides essential capabilities for humanoid robotics simulation:

1. **Realistic Physics Engine**: Advanced collision detection and dynamics simulation
2. **Sensor Simulation**: Cameras, LiDAR, IMUs, force/torque sensors, and more
3. **3D Visualization**: Real-time rendering of robot and environment
4. **Plugin Architecture**: Extensible system for custom sensors and controllers
5. **ROS Integration**: Seamless integration with ROS/ROS2 communication

### Why Gazebo for Humanoid Robotics?

Humanoid robots require complex simulation environments due to their:
- Multi-degree-of-freedom systems
- Balance and locomotion challenges
- Interaction with diverse environments
- Safety-critical operations requiring extensive testing

## Gazebo Architecture and Components

### Core Architecture

Gazebo's architecture consists of several key components:

```xml
<!-- Example Gazebo World Configuration -->
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_world">
    <!-- Physics Engine Configuration -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
      <gravity>0 0 -9.8</gravity>
    </physics>

    <!-- Environment Lighting -->
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.6 0.4 -0.8</direction>
    </light>

    <!-- Ground Plane -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>1.0</mu>
                <mu2>1.0</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

### Physics Engine Configuration

For humanoid robots, physics parameters are critical for realistic simulation:

```python
import math

class GazeboPhysicsConfig:
    def __init__(self):
        # Time step configuration for stability
        self.max_step_size = 0.001  # 1ms for stability with fast dynamics
        self.real_time_factor = 1.0  # Real-time simulation
        self.real_time_update_rate = 1000  # Hz

        # Gravity settings (Earth standard)
        self.gravity = [0, 0, -9.81]  # m/s^2

        # Solver parameters for humanoid stability
        self.solver_type = "ode"  # Open Dynamics Engine
        self.ode_iterations = 100  # Higher for stability
        self.ode_sor = 1.3  # Successive Over-Relaxation parameter

    def get_optimized_params_for_humanoid(self, robot_mass):
        """Optimize physics parameters based on robot mass"""
        params = {
            'max_step_size': min(0.001, 0.01 / math.sqrt(robot_mass)),
            'real_time_factor': 1.0,
            'real_time_update_rate': 1000,
            'gravity': self.gravity,
            'solver_iterations': max(100, int(robot_mass * 5))
        }
        return params

# Example usage for a 50kg humanoid robot
humanoid_config = GazeboPhysicsConfig()
optimized_params = humanoid_config.get_optimized_params_for_humanoid(50.0)
print(f"Optimized parameters: {optimized_params}")
```

## Environment Creation and Modeling

### Creating Custom Environments

Gazebo environments for humanoid robots should include:

1. **Terrain Varieties**: Flat ground, slopes, stairs, uneven surfaces
2. **Obstacles**: Furniture, walls, narrow passages
3. **Interactive Objects**: Doors, switches, tools
4. **Sensor Calibration Areas**: Known landmarks and reference points

```xml
<!-- Complex Indoor Environment for Humanoid Testing -->
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_indoor_test">
    <include>
      <uri>model://ground_plane</uri>
    </include>
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Room with obstacles -->
    <model name="test_room">
      <!-- Room walls -->
      <pose>0 0 1.5 0 0 0</pose>
      <link name="room_structure">
        <!-- Wall geometries would be defined here -->
      </link>

      <!-- Furniture obstacles -->
      <model name="table">
        <pose>2 0 0.4 0 0 0</pose>
        <link name="table_base">
          <collision name="collision">
            <geometry>
              <box>
                <size>1.0 0.6 0.8</size>
              </box>
            </geometry>
          </collision>
          <visual name="visual">
            <geometry>
              <box>
                <size>1.0 0.6 0.8</size>
              </box>
            </geometry>
            <material>
              <ambient>0.6 0.4 0.2 1</ambient>
              <diffuse>0.6 0.4 0.2 1</diffuse>
            </material>
          </visual>
        </link>
      </model>

      <!-- Stairs for locomotion testing -->
      <model name="stairs">
        <pose>-2 0 0 0 0 0</pose>
        <!-- Stair geometry definition -->
      </model>
    </model>
  </world>
</sdf>
```

### Terrain Modeling for Humanoid Testing

```python
class TerrainGenerator:
    def __init__(self):
        self.terrain_types = {
            'flat': self.create_flat_terrain,
            'sloped': self.create_sloped_terrain,
            'stepped': self.create_stepped_terrain,
            'uneven': self.create_uneven_terrain
        }

    def create_flat_terrain(self, size=10.0):
        """Create a flat terrain for basic locomotion testing"""
        terrain_model = f"""
        <sdf version="1.7">
          <model name="flat_terrain">
            <static>true</static>
            <link name="ground">
              <collision name="collision">
                <geometry>
                  <plane>
                    <normal>0 0 1</normal>
                    <size>{size} {size}</size>
                  </plane>
                </geometry>
              </collision>
              <visual name="visual">
                <geometry>
                  <plane>
                    <normal>0 0 1</normal>
                    <size>{size} {size}</size>
                  </plane>
                </geometry>
                <material>
                  <ambient>0.7 0.7 0.7 1</ambient>
                  <diffuse>0.7 0.7 0.7 1</diffuse>
                  <specular>0.1 0.1 0.1 1</specular>
                </material>
              </visual>
            </link>
          </model>
        </sdf>
        """
        return terrain_model

    def create_sloped_terrain(self, angle=15.0, size=5.0):
        """Create a sloped terrain for balance testing"""
        # Convert angle to radians
        angle_rad = math.radians(angle)
        height = size * math.tan(angle_rad)

        terrain_model = f"""
        <sdf version="1.7">
          <model name="sloped_terrain_{angle}deg">
            <static>true</static>
            <pose>0 0 {height/2} 0 0 {angle_rad}</pose>
            <link name="slope">
              <collision name="collision">
                <geometry>
                  <box>
                    <size>{size} 3.0 {height}</size>
                  </box>
                </geometry>
              </collision>
              <visual name="visual">
                <geometry>
                  <box>
                    <size>{size} 3.0 {height}</size>
                  </box>
                </geometry>
                <material>
                  <ambient>0.5 0.7 0.5 1</ambient>
                  <diffuse>0.5 0.7 0.5 1</diffuse>
                </material>
              </visual>
            </link>
          </model>
        </sdf>
        """
        return terrain_model

    def create_stepped_terrain(self, step_height=0.1, num_steps=5):
        """Create stepped terrain for stair climbing testing"""
        model_xml = '<sdf version="1.7">\n  <model name="stepped_terrain">\n    <static>true</static>\n'

        for i in range(num_steps):
            step_z = (i + 1) * step_height
            step_x = i * 0.3  # Each step is 0.3m apart

            step_xml = f"""
    <link name="step_{i+1}">
      <pose>{step_x} 0 {step_z} 0 0 0</pose>
      <collision name="collision_{i+1}">
        <geometry>
          <box>
            <size>0.4 1.0 {step_height}</size>
          </box>
        </geometry>
      </collision>
      <visual name="visual_{i+1}">
        <geometry>
          <box>
            <size>0.4 1.0 {step_height}</size>
          </box>
        </geometry>
        <material>
          <ambient>0.8 0.6 0.2 1</ambient>
          <diffuse>0.8 0.6 0.2 1</diffuse>
        </material>
      </visual>
    </link>
"""
            model_xml += step_xml

        model_xml += '  </model>\n</sdf>'
        return model_xml

# Example usage
terrain_gen = TerrainGenerator()
flat_terrain = terrain_gen.create_flat_terrain(20.0)
sloped_terrain = terrain_gen.create_sloped_terrain(20.0, 6.0)
stepped_terrain = terrain_gen.create_stepped_terrain(0.15, 4)

print("Terrain models generated successfully")
```

## Sensor Simulation in Gazebo

### Camera Sensors

```python
class GazeboCameraSensor:
    def __init__(self, name="humanoid_camera", resolution=(640, 480)):
        self.name = name
        self.resolution = resolution
        self.hfov = 1.0472  # 60 degrees in radians

    def generate_camera_sdf(self):
        """Generate SDF for RGB camera sensor"""
        camera_sdf = f"""
      <sensor name="{self.name}" type="camera">
        <camera name="{self.name}_camera">
          <horizontal_fov>{self.hfov}</horizontal_fov>
          <image>
            <width>{self.resolution[0]}</width>
            <height>{self.resolution[1]}</height>
            <format>R8G8B8</format>
          </image>
          <clip>
            <near>0.1</near>
            <far>10.0</far>
          </clip>
        </camera>
        <always_on>1</always_on>
        <update_rate>30</update_rate>
        <visualize>true</visualize>
      </sensor>
"""
        return camera_sdf

# Example: Head-mounted camera for humanoid
head_camera = GazeboCameraSensor("head_camera", (1280, 720))
head_camera_sdf = head_camera.generate_camera_sdf()
```

### IMU Sensors for Balance

```python
class GazeboIMUMount:
    def __init__(self, name="imu_sensor", parent_link="base_link"):
        self.name = name
        self.parent_link = parent_link

    def generate_imu_sdf(self):
        """Generate SDF for IMU sensor"""
        imu_sdf = f"""
      <sensor name="{self.name}" type="imu">
        <always_on>true</always_on>
        <update_rate>100</update_rate>
        <imu>
          <angular_velocity>
            <x>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>2e-4</stddev>
              </noise>
            </x>
            <y>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>2e-4</stddev>
              </noise>
            </y>
            <z>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>2e-4</stddev>
              </noise>
            </z>
          </angular_velocity>
          <linear_acceleration>
            <x>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>1.7e-2</stddev>
              </noise>
            </x>
            <y>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>1.7e-2</stddev>
              </noise>
            </y>
            <z>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>1.7e-2</stddev>
              </noise>
            </z>
          </linear_acceleration>
        </imu>
      </sensor>
"""
        return imu_sdf

# Example: IMU in torso for balance control
torso_imu = GazeboIMUMount("torso_imu", "torso_link")
torso_imu_sdf = torso_imu.generate_imu_sdf()
```

### Force/Torque Sensors

```python
class GazeboForceTorqueSensor:
    def __init__(self, name="ft_sensor", joint_name="ankle_joint"):
        self.name = name
        self.joint_name = joint_name

    def generate_ft_sdf(self):
        """Generate SDF for force/torque sensor"""
        ft_sdf = f"""
      <sensor name="{self.name}" type="force_torque">
        <always_on>true</always_on>
        <update_rate>100</update_rate>
        <force_torque>
          <frame>child</frame>
          <measure_direction>child_to_parent</measure_direction>
        </force_torque>
        <parent>{self.joint_name}</parent>
      </sensor>
"""
        return ft_sdf

# Example: Force/torque sensors in feet
left_foot_ft = GazeboForceTorqueSensor("left_foot_ft", "left_ankle_joint")
right_foot_ft = GazeboForceTorqueSensor("right_foot_ft", "right_ankle_joint")
```

## Physics Parameter Tuning for Humanoid Robots

### Material Properties

```python
class MaterialProperties:
    def __init__(self):
        self.materials = {
            'rubber_foot': {
                'mu1': 1.0,  # Primary friction coefficient
                'mu2': 1.0,  # Secondary friction coefficient
                'kp': 1e9,   # Spring coefficient
                'kd': 1.0    # Damping coefficient
            },
            'metal_joint': {
                'mu1': 0.5,
                'mu2': 0.5,
                'kp': 1e8,
                'kd': 0.5
            },
            'plastic_body': {
                'mu1': 0.8,
                'mu2': 0.8,
                'kp': 1e7,
                'kd': 0.2
            }
        }

    def get_material_sdf(self, material_type, geometry_name):
        """Generate SDF for specific material properties"""
        if material_type not in self.materials:
            raise ValueError(f"Unknown material type: {material_type}")

        props = self.materials[material_type]

        material_sdf = f"""
    <surface>
      <friction>
        <ode>
          <mu>{props['mu1']}</mu>
          <mu2>{props['mu2']}</mu2>
        </ode>
      </friction>
      <bounce>
        <restitution_coefficient>0.01</restitution_coefficient>
        <threshold>100000</threshold>
      </bounce>
      <contact>
        <ode>
          <kp>{props['kp']}</kp>
          <kd>{props['kd']}</kd>
          <max_vel>100.0</max_vel>
          <min_depth>0.001</min_depth>
        </ode>
      </contact>
    </surface>
"""
        return material_sdf

# Example usage for humanoid foot material
mat_props = MaterialProperties()
foot_material = mat_props.get_material_sdf('rubber_foot', 'foot_collision')
```

### Mass and Inertia Optimization

```python
import numpy as np

class InertiaCalculator:
    @staticmethod
    def box_inertia(mass, dimensions):
        """Calculate inertia tensor for a box"""
        x, y, z = dimensions
        ixx = (1/12) * mass * (y**2 + z**2)
        iyy = (1/12) * mass * (x**2 + z**2)
        izz = (1/12) * mass * (x**2 + y**2)

        return np.array([
            [ixx, 0, 0],
            [0, iyy, 0],
            [0, 0, izz]
        ])

    @staticmethod
    def cylinder_inertia(mass, radius, height):
        """Calculate inertia tensor for a cylinder"""
        ixx = (1/12) * mass * (3 * radius**2 + height**2)
        iyy = (1/12) * mass * (3 * radius**2 + height**2)
        izz = 0.5 * mass * radius**2

        return np.array([
            [ixx, 0, 0],
            [0, iyy, 0],
            [0, 0, izz]
        ])

    @staticmethod
    def sphere_inertia(mass, radius):
        """Calculate inertia tensor for a sphere"""
        ixx = iyy = izz = (2/5) * mass * radius**2

        return np.array([
            [ixx, 0, 0],
            [0, iyy, 0],
            [0, 0, izz]
        ])

# Example: Calculate inertia for humanoid body parts
inertia_calc = InertiaCalculator()

# Torso (approximated as box: 0.3x0.2x0.5m, mass 15kg)
torso_inertia = inertia_calc.box_inertia(15.0, (0.3, 0.2, 0.5))

# Upper arm (approximated as cylinder: radius 0.05m, height 0.3m, mass 2kg)
upper_arm_inertia = inertia_calc.cylinder_inertia(2.0, 0.05, 0.3)

# Foot (approximated as box: 0.25x0.1x0.08m, mass 1kg)
foot_inertia = inertia_calc.box_inertia(1.0, (0.25, 0.1, 0.08))

print("Humanoid body part inertias calculated")
```

## Gazebo Plugins for Humanoid Robotics

### Custom Control Plugin Example

```cpp
// Example C++ plugin for humanoid joint control
/*
 * HumanoidJointController.hh
 * Custom Gazebo plugin for humanoid robot joint control
 */
#ifndef HUMANOID_JOINT_CONTROLLER_HH_
#define HUMANOID_JOINT_CONTROLLER_HH_

#include <gazebo/common/Plugin.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/transport/transport.hh>
#include <gazebo/msgs/msgs.hh>
#include <std_msgs/Float64MultiArray.h>
#include <ros/ros.h>

namespace gazebo
{
  class HumanoidJointController : public ModelPlugin
  {
    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
    {
      this->model = _model;
      this->world = _model->GetWorld();

      // Initialize joints from SDF parameters
      if (_sdf->HasElement("joint"))
      {
        sdf::ElementPtr joint_elem = _sdf->GetElement("joint");
        while (joint_elem)
        {
          std::string joint_name = joint_elem->Get<std::string>();
          physics::JointPtr joint = this->model->GetJoint(joint_name);
          if (joint)
          {
            this->joints.push_back(joint);
            this->joint_names.push_back(joint_name);
          }
          joint_elem = joint_elem->GetNextElement("joint");
        }
      }

      // Initialize ROS node
      if (!ros::isInitialized())
      {
        int argc = 0;
        char** argv = NULL;
        ros::init(argc, argv, "gazebo_humanoid_controller",
                  ros::init_options::NoSigintHandler);
      }

      this->ros_node.reset(new ros::NodeHandle());

      // Subscribe to joint commands
      this->cmd_sub = this->ros_node->subscribe(
        "/humanoid_joint_commands", 1000,
        &HumanoidJointController::OnJointCmd, this);

      // Connect to Gazebo update event
      this->update_connection = event::Events::ConnectWorldUpdateBegin(
          std::bind(&HumanoidJointController::OnUpdate, this));
    }

    public: void OnJointCmd(const std_msgs::Float64MultiArray::ConstPtr& msg)
    {
      if (msg->data.size() == this->joints.size())
      {
        for (size_t i = 0; i < this->joints.size(); ++i)
        {
          // Set joint position target (PD controller would be implemented here)
          this->joints[i]->SetPosition(0, msg->data[i]);
        }
      }
    }

    public: void OnUpdate()
    {
      // Custom control logic would go here
      // This runs at Gazebo's update rate
    }

    private: physics::ModelPtr model;
    private: physics::WorldPtr world;
    private: std::vector<physics::JointPtr> joints;
    private: std::vector<std::string> joint_names;
    private: ros::Subscriber cmd_sub;
    private: std::unique_ptr<ros::NodeHandle> ros_node;
    private: event::ConnectionPtr update_connection;
  };

  GZ_REGISTER_MODEL_PLUGIN(HumanoidJointController)
}

#endif
```

## Integration with ROS 2

### Launch Configuration

```python
# launch/humanoid_gazebo.launch.py
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    return LaunchDescription([
        # Start Gazebo with custom world
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([
                PathJoinSubstitution([
                    FindPackageShare('gazebo_ros'),
                    'launch',
                    'gazebo.launch.py'
                ])
            ]),
            launch_arguments={
                'world': PathJoinSubstitution([
                    FindPackageShare('humanoid_robot_description'),
                    'worlds',
                    'humanoid_test.world'
                ])
            }.items()
        ),

        # Robot state publisher
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            parameters=[{
                'use_sim_time': True,
                'robot_description': open(PathJoinSubstitution([
                    FindPackageShare('humanoid_robot_description'),
                    'urdf',
                    'humanoid.urdf'
                ]).perform({})).read()
            }]
        ),

        # Joint state publisher
        Node(
            package='joint_state_publisher',
            executable='joint_state_publisher',
            name='joint_state_publisher',
            parameters=[{'use_sim_time': True}]
        )
    ])
```

## Validation and Testing

### Simulation Validation Framework

```python
class SimulationValidator:
    def __init__(self):
        self.metrics = {
            'physics_stability': self.validate_physics_stability,
            'sensor_accuracy': self.validate_sensor_accuracy,
            'kinematic_consistency': self.validate_kinematic_consistency,
            'dynamic_response': self.validate_dynamic_response
        }

    def validate_physics_stability(self, robot_model):
        """Validate physics simulation stability"""
        # Check for joint limit violations
        # Check for excessive velocities
        # Verify energy conservation in passive systems
        stability_score = 0.95  # Placeholder value
        return stability_score

    def validate_sensor_accuracy(self, sensor_data, expected_values):
        """Validate sensor simulation accuracy"""
        # Compare simulated sensor readings with expected values
        # Calculate accuracy metrics
        accuracy_score = 0.92  # Placeholder value
        return accuracy_score

    def validate_kinematic_consistency(self, joint_positions, end_effector_poses):
        """Validate kinematic chain consistency"""
        # Forward kinematics validation
        # Inverse kinematics validation
        consistency_score = 0.98  # Placeholder value
        return consistency_score

    def validate_dynamic_response(self, applied_forces, resulting_motion):
        """Validate dynamic response realism"""
        # Verify Newton's laws application
        # Check for realistic acceleration profiles
        response_score = 0.90  # Placeholder value
        return response_score

    def run_comprehensive_validation(self, robot_model):
        """Run all validation checks"""
        results = {}
        for metric_name, validator in self.metrics.items():
            if metric_name == 'sensor_accuracy':
                results[metric_name] = validator(None, None)  # Specific parameters needed
            elif metric_name == 'kinematic_consistency':
                results[metric_name] = validator(None, None)  # Specific parameters needed
            elif metric_name == 'dynamic_response':
                results[metric_name] = validator(None, None)  # Specific parameters needed
            else:
                results[metric_name] = validator(robot_model)

        overall_score = sum(results.values()) / len(results)
        return results, overall_score

# Example usage
validator = SimulationValidator()
# validation_results, overall_score = validator.run_comprehensive_validation(humanoid_model)
# print(f"Validation Results: {validation_results}")
# print(f"Overall Score: {overall_score:.2f}")
```

## Performance Optimization

### Simulation Performance Tuning

```python
class PerformanceOptimizer:
    def __init__(self):
        self.optimization_strategies = {
            'time_step': self.optimize_time_step,
            'collision_meshes': self.optimize_collision_meshes,
            'sensor_updates': self.optimize_sensor_updates,
            'physics_complexity': self.optimize_physics_complexity
        }

    def optimize_time_step(self, target_real_time_factor=1.0):
        """Optimize simulation time step for target real-time factor"""
        # Adaptive time stepping based on simulation complexity
        optimal_step = 0.001  # Start with 1ms
        return optimal_step

    def optimize_collision_meshes(self, complexity_level='medium'):
        """Optimize collision meshes for performance"""
        # Simplified collision meshes for distant objects
        # Detailed meshes for contact-critical areas
        optimization_params = {
            'level': complexity_level,
            'contact_precision': 0.001 if complexity_level == 'high' else 0.01
        }
        return optimization_params

    def optimize_sensor_updates(self, sensor_types):
        """Optimize sensor update rates for performance"""
        update_rates = {
            'imu': 100,      # Hz - high rate for balance control
            'camera': 30,    # Hz - standard video rate
            'lidar': 10,     # Hz - lower rate for efficiency
            'force_torque': 100  # Hz - high rate for control
        }
        return {sensor: update_rates.get(sensor, 50) for sensor in sensor_types}

    def optimize_physics_complexity(self, robot_dof, target_framerate=1000):
        """Optimize physics complexity based on robot DOF"""
        complexity_settings = {
            'solver_iterations': min(200, max(50, robot_dof * 2)),
            'contact_surface_layer': 0.001,
            'max_contacts': 20
        }
        return complexity_settings

# Example optimization for 28-DOF humanoid
perf_optimizer = PerformanceOptimizer()
time_step = perf_optimizer.optimize_time_step()
collision_opt = perf_optimizer.optimize_collision_meshes('high')
sensor_rates = perf_optimizer.optimize_sensor_updates(['imu', 'camera', 'force_torque'])
physics_params = perf_optimizer.optimize_physics_complexity(28)

print("Performance optimization parameters calculated")
```

## Best Practices and Guidelines

### Simulation Best Practices

1. **Start Simple**: Begin with basic environments and gradually increase complexity
2. **Validate Early**: Regularly validate simulation against physical properties
3. **Monitor Performance**: Keep real-time factor close to 1.0 for consistent results
4. **Use Appropriate Fidelity**: Match simulation fidelity to testing requirements
5. **Document Parameters**: Maintain detailed records of physics and material parameters

### Troubleshooting Common Issues

```python
class GazeboTroubleshooter:
    def __init__(self):
        self.common_issues = {
            'instability': self.troubleshoot_instability,
            'penetration': self.troubleshoot_penetration,
            'slow_performance': self.troubleshoot_performance,
            'sensor_noise': self.troubleshoot_sensor_noise
        }

    def troubleshoot_instability(self):
        """Common fixes for simulation instability"""
        fixes = [
            "Reduce time step (max_step_size)",
            "Increase solver iterations",
            "Check mass distribution and inertias",
            "Verify joint limits and stiffness"
        ]
        return fixes

    def troubleshoot_penetration(self):
        """Common fixes for object penetration"""
        fixes = [
            "Increase contact surface layer",
            "Improve collision mesh resolution",
            "Adjust friction parameters",
            "Verify geometry overlaps"
        ]
        return fixes

    def troubleshoot_performance(self):
        """Common fixes for slow performance"""
        fixes = [
            "Simplify collision meshes",
            "Reduce sensor update rates",
            "Optimize physics parameters",
            "Reduce world complexity"
        ]
        return fixes

    def troubleshoot_sensor_noise(self):
        """Common fixes for excessive sensor noise"""
        fixes = [
            "Verify noise parameters in SDF",
            "Check physics stability",
            "Increase simulation update rate",
            "Validate sensor mounting"
        ]
        return fixes

# Example usage
troubleshooter = GazeboTroubleshooter()
instability_fixes = troubleshooter.troubleshoot_instability()
print("Common instability fixes:", instability_fixes)
```

## Summary

Gazebo simulation environments provide essential capabilities for humanoid robotics development, enabling safe and cost-effective testing of complex control algorithms. Proper configuration of physics parameters, sensor models, and environment complexity is crucial for realistic simulation that translates effectively to real-world performance. The validation framework ensures simulation accuracy, while performance optimization maintains real-time operation for interactive testing.

## Exercises

1. Create a custom Gazebo world with multiple terrain types for humanoid locomotion testing
2. Implement a sensor fusion system combining IMU, camera, and force/torque data
3. Develop a validation framework comparing simulation and real-world robot behavior
4. Optimize physics parameters for a specific humanoid robot model
5. Create a complex indoor environment with interactive objects for human-robot interaction testing